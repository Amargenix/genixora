<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to DSA</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- ‚úÖ FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../opp.css">

</head>

<body>

    <!-- Navbar Placeholder -->
    <div id="navbar-placeholder"></div>

    <div class="container-fluid">
        <div class="row">


            <!-- Sidebar for DSA Topics -->
            <nav class="sidebar">
                <h2>DSA Topics</h2>
                <input type="text" id="searchBox" class="form-control mb-2" placeholder="Search topics...">
                
                <!-- Sidebar List (Will Adjust in Mobile View) -->
                <ul id="topics-list" class="list-group d-none d-md-block"></ul>  <!-- Hidden in mobile -->

                <!-- Mobile Grid View -->
                <div id="topics-grid" class="d-md-none row gx-2"></div>  <!-- Visible in mobile -->
            </nav>


            <main class="col-md-7 content">
                <h2>üîπ Smart Pointers in Programming</h2>
            
                <p>
                    **Smart pointers** are a type of data structure that encapsulates a raw pointer and provides automatic memory management. They help in managing the lifetime of dynamically allocated objects, preventing memory leaks and dangling pointers. Smart pointers are particularly important in modern programming languages, such as C++ and Rust, where manual memory management can lead to common errors.
                </p>
            
                <h3>üìå Why Use Smart Pointers?</h3>
                <p>Smart pointers offer several advantages over traditional raw pointers:</p>
                <ul>
                    <li>‚úÖ **Automatic Memory Management**: Smart pointers automatically release the memory allocated for an object when it is no longer needed.</li>
                    <li>‚úÖ **Prevent Memory Leaks**: By ensuring proper memory deallocation, smart pointers help prevent memory leaks in applications.</li>
                    <li>‚úÖ **Eliminate Dangling Pointers**: Smart pointers keep track of the object‚Äôs lifetime, reducing the chances of accessing invalid memory locations.</li>
                    <li>‚úÖ **Enhanced Exception Safety**: Smart pointers provide better exception safety by ensuring that resources are released even in the presence of exceptions.</li>
                </ul>
            
                <h3>üìå Types of Smart Pointers</h3>
                <p>There are several types of smart pointers, each with its specific use cases:</p>
                <ul>
                    <li><b>Unique Pointer (std::unique_ptr)</b>: A smart pointer that owns a dynamically allocated object and ensures that there is only one owner. The object is automatically destroyed when the unique pointer goes out of scope.</li>
                    <li><b>Shared Pointer (std::shared_ptr)</b>: A smart pointer that allows multiple pointers to share ownership of a dynamically allocated object. The object is destroyed when the last shared pointer pointing to it is destroyed.</li>
                    <li><b>Weak Pointer (std::weak_ptr)</b>: A smart pointer that does not affect the reference count of a shared pointer. It is used to break circular references and provide access to an object managed by a shared pointer without owning it.</li>
                </ul>
            
                <h3>üñ•Ô∏è Smart Pointer Example in C++</h3>
                <p>Here is an example of using smart pointers in C++:</p>
                <pre><code>
            #include &lt;iostream&gt;
            #include &lt;memory&gt;
            
            class Resource {
            public:
                Resource() {
                    std::cout &lt;&lt; "Resource acquired." &lt;&lt; std::endl;
                }
                ~Resource() {
                    std::cout &lt;&lt; "Resource destroyed." &lt;&lt; std::endl;
                }
            };
            
            int main() {
                // Using unique pointer
                std::unique_ptr<Resource> uniquePtr(new Resource());
            
                // Using shared pointer
                std::shared_ptr<Resource> sharedPtr1(new Resource());
                std::shared_ptr<Resource> sharedPtr2 = sharedPtr1; // Shared ownership
            
                return 0; // Resources will be automatically released
            }
                </code></pre>
            
                <h3>üñ•Ô∏è Smart Pointer Example in Rust</h3>
                <p>Here is an example of using smart pointers in Rust:</p>
                <pre><code>
            struct Resource {
                name: String,
            }
            
            impl Resource {
                fn new(name: &str) -> Resource {
                    Resource {
                        name: name.to_string(),
                    }
                }
            }
            
            fn main() {
                // Using Box as a unique pointer
                let unique_ptr = Box::new(Resource::new("Unique Resource"));
            
                // Using Rc for shared ownership
                let shared_ptr1 = std::rc::Rc::new(Resource::new("Shared Resource"));
                let shared_ptr2 = std::rc::Rc::clone(&shared_ptr1); // Clone for shared ownership
            
                // Resources will be automatically released when they go out of scope
            }
                </code></pre>
            
                <h3>üìå Best Practices for Using Smart Pointers</h3>
                <ul>
                    <li>‚úÖ **Prefer Smart Pointers Over Raw Pointers**: Use smart pointers for dynamic memory management instead of raw pointers to improve safety and reliability.</li>
                    <li>‚úÖ **Avoid Circular References**: When using shared pointers, be cautious of creating circular references, as they can lead to memory leaks. Use weak pointers to resolve this issue.</li>
                    <li>‚úÖ **Use Unique Pointers for Exclusive Ownership**: When you want to ensure that only one owner exists for an object, prefer using unique pointers.</li>
                    <li>‚úÖ **Leverage Automatic Memory Management**: Take advantage of the automatic memory management features of smart pointers to simplify your code and reduce the chances of memory-related errors.</li>
                </ul>
            
                <h3>üéØ Summary</h3>
                <p>
                    Smart pointers are an essential tool in modern programming that simplifies memory management and enhances code safety.  
                    By providing automatic memory management, smart pointers help prevent memory leaks and dangling pointers, contributing to more robust applications.  
                    Understanding how to use different types of smart pointers effectively is crucial for writing clean and maintainable code.
                </p>
            
                <h2>üîó Next Topics</h2>
                <ul class="nexttopics-container">
                    <li><a href="memory_management.html">üëâ Memory Management</a></li>
                    <li><a href="ownership_borrowing.html">üëâ Ownership and Borrowing in Rust</a></li>
                    <li><a href="memory_safety.html">üëâ Memory Safety in Programming</a></li>
                </ul>
            </main>
            












     
    <!-- Footer Placeholder -->
    <div id="footer-placeholder"></div>
    <div>
        <!-- üîù Back to Top Button -->
        <button id="backToTop" class="btn btn-primary">
            ‚¨Ü Top
        </button>
        </div>
        <!-- Bootstrap JS -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
        <!-- Load Navbar, Sidebar, and Footer -->
        <script>
            fetch("/navbar.html").then(response => response.text()).then(data => {
                document.getElementById("navbar-placeholder").innerHTML = data;
            });
    
            
    
            fetch("/footer.html").then(response => response.text()).then(data => {
                document.getElementById("footer-placeholder").innerHTML = data;
            });
        </script>
    
    
    <script>
    document.addEventListener("DOMContentLoaded", function () {
        const sidebarList = document.getElementById("topics-list"); // Normal list for desktop
        const sidebarGrid = document.getElementById("topics-grid"); // Grid view for mobile
        const searchBox = document.getElementById("searchBox");
    
        if (!sidebarList || !sidebarGrid) {
            console.error("Sidebar elements not found!");
            return;
        }
    
        let allTopics = [];
    
        // Adjust JSON path based on file location
        let jsonPath = window.location.pathname.includes("/topics/") ? "../opp.json" : "opp.json";
    
        console.log("Fetching JSON from:", jsonPath); // Debugging
    
        // Fetch DSA Topics from JSON
        fetch(jsonPath)
            .then(response => {
                if (!response.ok) {
                    throw new Error("Failed to load JSON");
                }
                return response.json();
            })
            .then(data => {
                allTopics = data.OOP;
                displayTopics(allTopics);
            })
            .catch(error => console.error("Error loading topics:", error));
    
        // Function to Display Topics in Sidebar
        function displayTopics(topics) {
            sidebarList.innerHTML = ""; // Clear list
            sidebarGrid.innerHTML = ""; // Clear grid
    
            topics.forEach(topic => {
                let topicLink = topic.link; // Keep the original link
                // üñ•Ô∏è Desktop List View
                let li = document.createElement("li");
                li.className = "list-group-item list-group-item-action";
                li.innerHTML = `<a href="${topicLink}" class="topic-link">${topic.name}</a>`;
                sidebarList.appendChild(li);
    
                // üì± Mobile Grid View (3 in a row)
                let div = document.createElement("div");
                div.className = "col-4"; // Bootstrap grid (3 in a row)
                div.innerHTML = `<a href="${topicLink}" class="btn btn-outline-primary w-100 p-2">${topic.name}</a>`;
                sidebarGrid.appendChild(div);
            });

        }
    
        // Search Topics
        if (searchBox) {
            searchBox.addEventListener("input", function () {
                const searchText = this.value.toLowerCase();
                const filteredTopics = allTopics.filter(topic => 
                    topic.name.toLowerCase().includes(searchText)
                );
                displayTopics(filteredTopics);
            });
        }
    });
    
    
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const backToTop = document.getElementById("backToTop");
    
            window.addEventListener("scroll", function () {
                if (window.scrollY > 300) {
                    backToTop.style.display = "block"; // Show button after scrolling 300px
                } else {
                    backToTop.style.display = "none"; // Hide button when at the top
                }
            });
    
            backToTop.addEventListener("click", function () {
                window.scrollTo({
                    top: 0,
                    behavior: "smooth" // Smooth scroll effect
                });
            });
        });
    </script>
    
    
    
    
    
    
    </body>
    </html>
    