<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to DSA</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- ✅ FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../opp.css">

</head>

<body>

    <!-- Navbar Placeholder -->
    <div id="navbar-placeholder"></div>

    <div class="container-fluid">
        <div class="row">


            <!-- Sidebar for DSA Topics -->
            <nav class="sidebar">
                <h2>DSA Topics</h2>
                <input type="text" id="searchBox" class="form-control mb-2" placeholder="Search topics...">
                
                <!-- Sidebar List (Will Adjust in Mobile View) -->
                <ul id="topics-list" class="list-group d-none d-md-block"></ul>  <!-- Hidden in mobile -->

                <!-- Mobile Grid View -->
                <div id="topics-grid" class="d-md-none row gx-2"></div>  <!-- Visible in mobile -->
            </nav>



            <main class="col-md-7 content">
                <h2>🔹 SOLID Principles in Software Design</h2>
            
                <p>
                    The **SOLID principles** are a set of five design principles intended to make software designs more understandable, flexible, and maintainable.  
                    These principles help developers create better object-oriented software by promoting better organization and reducing code smells.
                </p>
            
                <h3>📌 Overview of SOLID Principles</h3>
                <p>SOLID is an acronym for the following five principles:</p>
                <ul>
                    <li><b>S</b> - Single Responsibility Principle (SRP)</li>
                    <li><b>O</b> - Open/Closed Principle (OCP)</li>
                    <li><b>L</b> - Liskov Substitution Principle (LSP)</li>
                    <li><b>I</b> - Interface Segregation Principle (ISP)</li>
                    <li><b>D</b> - Dependency Inversion Principle (DIP)</li>
                </ul>
            
                <h3>📌 1. Single Responsibility Principle (SRP)</h3>
                <p>The Single Responsibility Principle states that a class should have only one reason to change, meaning it should have only one responsibility or job.</p>
                <p>This principle encourages developers to organize code around specific functionalities, making it easier to maintain and modify.</p>
                <pre><code>
            class Report {
                public:
                    void generate() {
                        // Code to generate report
                    }
            };
            
            class ReportPrinter {
                public:
                    void print(Report report) {
                        // Code to print report
                    }
            };
                </code></pre>
            
                <h3>📌 2. Open/Closed Principle (OCP)</h3>
                <p>The Open/Closed Principle states that software entities (classes, modules, functions) should be open for extension but closed for modification.</p>
                <p>This means that you should be able to add new functionality without changing existing code, which reduces the risk of introducing bugs.</p>
                <pre><code>
            class Shape {
                public:
                    virtual double area() = 0; // Abstract method
            };
            
            class Circle : public Shape {
                double radius;
                public:
                    double area() {
                        return 3.14 * radius * radius;
                    }
            };
            
            class Square : public Shape {
                double side;
                public:
                    double area() {
                        return side * side;
                    }
            };
                </code></pre>
            
                <h3>📌 3. Liskov Substitution Principle (LSP)</h3>
                <p>The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.</p>
                <p>This principle ensures that subclasses extend the behavior of the parent class without changing its intended behavior.</p>
                <pre><code>
            class Bird {
                public:
                    virtual void fly() = 0;
            };
            
            class Sparrow : public Bird {
                public:
                    void fly() {
                        // Sparrow flying behavior
                    }
            };
            
            class Ostrich : public Bird {
                public:
                    void fly() {
                        throw "Ostrich can't fly"; // Violates LSP
                    }
            };
                </code></pre>
            
                <h3>📌 4. Interface Segregation Principle (ISP)</h3>
                <p>The Interface Segregation Principle states that no client should be forced to depend on methods it does not use.</p>
                <p>This principle encourages the creation of smaller, more specific interfaces rather than large, general-purpose ones, leading to more understandable and maintainable code.</p>
                <pre><code>
            class Printer {
                public:
                    virtual void print() = 0;
            };
            
            class Scanner {
                public:
                    virtual void scan() = 0;
            };
            
            class AllInOnePrinter : public Printer, public Scanner {
                public:
                    void print() {
                        // Print functionality
                    }
                    void scan() {
                        // Scan functionality
                    }
            };
                </code></pre>
            
                <h3>📌 5. Dependency Inversion Principle (DIP)</h3>
                <p>The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
                <p>This principle promotes the use of interfaces or abstract classes to decouple high-level logic from low-level implementations, resulting in more flexible and maintainable code.</p>
                <pre><code>
            class Database {
                public:
                    virtual void connect() = 0; // Abstraction
            };
            
            class MySQLDatabase : public Database {
                public:
                    void connect() {
                        // MySQL connection logic
                    }
            };
            
            class Application {
                Database *db; // Dependency on abstraction
                public:
                    Application(Database *database) : db(database) {}
                    void start() {
                        db->connect();
                    }
            };
                </code></pre>
            
                <h3>🎯 Summary</h3>
                <p>
                    The SOLID principles are foundational concepts in object-oriented design that enhance code maintainability and flexibility.  
                    By adhering to these principles, developers can create more robust software that is easier to understand, modify, and extend.  
                    Implementing these principles helps in reducing code smells and improving overall software quality.
                </p>
            
                <h2>🔗 Next Topics</h2>
                <ul class="nexttopics-container">
                    <li><a href="design_patterns.html">👉 Design Patterns</a></li>
                    <li><a href="refactoring.html">👉 Refactoring Techniques</a></li>
                    <li><a href="code_smells.html">👉 Identifying Code Smells</a></li>
                </ul>
            </main>
            












     
    <!-- Footer Placeholder -->
    <div id="footer-placeholder"></div>
    <div>
        <!-- 🔝 Back to Top Button -->
        <button id="backToTop" class="btn btn-primary">
            ⬆ Top
        </button>
        </div>
        <!-- Bootstrap JS -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
        <!-- Load Navbar, Sidebar, and Footer -->
        <script>
            fetch("/navbar.html").then(response => response.text()).then(data => {
                document.getElementById("navbar-placeholder").innerHTML = data;
            });
    
            
    
            fetch("/footer.html").then(response => response.text()).then(data => {
                document.getElementById("footer-placeholder").innerHTML = data;
            });
        </script>
    
    
    <script>
    document.addEventListener("DOMContentLoaded", function () {
        const sidebarList = document.getElementById("topics-list"); // Normal list for desktop
        const sidebarGrid = document.getElementById("topics-grid"); // Grid view for mobile
        const searchBox = document.getElementById("searchBox");
    
        if (!sidebarList || !sidebarGrid) {
            console.error("Sidebar elements not found!");
            return;
        }
    
        let allTopics = [];
    
        // Adjust JSON path based on file location
        let jsonPath = window.location.pathname.includes("/topics/") ? "../opp.json" : "opp.json";
    
        console.log("Fetching JSON from:", jsonPath); // Debugging
    
        // Fetch DSA Topics from JSON
        fetch(jsonPath)
            .then(response => {
                if (!response.ok) {
                    throw new Error("Failed to load JSON");
                }
                return response.json();
            })
            .then(data => {
                allTopics = data.OOP;
                displayTopics(allTopics);
            })
            .catch(error => console.error("Error loading topics:", error));
    
        // Function to Display Topics in Sidebar
        function displayTopics(topics) {
            sidebarList.innerHTML = ""; // Clear list
            sidebarGrid.innerHTML = ""; // Clear grid
    
            topics.forEach(topic => {
                let topicLink = topic.link; // Keep the original link
                // 🖥️ Desktop List View
                let li = document.createElement("li");
                li.className = "list-group-item list-group-item-action";
                li.innerHTML = `<a href="${topicLink}" class="topic-link">${topic.name}</a>`;
                sidebarList.appendChild(li);
    
                // 📱 Mobile Grid View (3 in a row)
                let div = document.createElement("div");
                div.className = "col-4"; // Bootstrap grid (3 in a row)
                div.innerHTML = `<a href="${topicLink}" class="btn btn-outline-primary w-100 p-2">${topic.name}</a>`;
                sidebarGrid.appendChild(div);
            });

        }
    
        // Search Topics
        if (searchBox) {
            searchBox.addEventListener("input", function () {
                const searchText = this.value.toLowerCase();
                const filteredTopics = allTopics.filter(topic => 
                    topic.name.toLowerCase().includes(searchText)
                );
                displayTopics(filteredTopics);
            });
        }
    });
    
    
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const backToTop = document.getElementById("backToTop");
    
            window.addEventListener("scroll", function () {
                if (window.scrollY > 300) {
                    backToTop.style.display = "block"; // Show button after scrolling 300px
                } else {
                    backToTop.style.display = "none"; // Hide button when at the top
                }
            });
    
            backToTop.addEventListener("click", function () {
                window.scrollTo({
                    top: 0,
                    behavior: "smooth" // Smooth scroll effect
                });
            });
        });
    </script>
    
    
    
    
    
    
    </body>
    </html>
    